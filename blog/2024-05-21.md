---
title: It's gonna be Legen... wait for it...
authors: [gagdiez]
slug: yield-resume
tags: [protocol, updates]
hide_table_of_contents: true
---

*dary! Legendary! NEAR protocol is getting updated with the ability to yield and resume computations*

![waiting on a loop](../website/static/docs/blog/legendary.jpg)

<!-- truncate -->

## Waiting on a Loop
Currently, smart contracts have no way to wait for an external event to happen. This can be a problem when the contract relies on an external service to provide a result.

Ourselves runned into this problem when implementing [Chain Signatures](/concepts/abstraction/chain-signatures), which work by requiring an external service to provide a signature.

So far, the only workaround for this has been to make the contract call itself on a loop, checking on each iteration if the result is ready. Each call delays the result by one block (~1 second), which gives the contract about a minute of waiting before it runs out of gas.

![waiting on a loop](../website/static/docs/blog/contract-wait-loop.png)
*Until now, contracts had to wait by calling themselves until a external service replies... more often than not the contract will run out of gas waiting*

While this method works, it is not ideal, since it wastes a lot of gas on looping, and more often than not it runs out of gas, forcing the user to retry the transaction.

## Yield and Resume
Starting from version `1.40` of the protocol, developers will be able to **delay executing** a function until some requirements are met (e.g. an external service provides a result).

This way, instead of the contract calling itself on a loop waiting for an external response, the contract can now **yield** giving the result, and wait until the external response is given, before **resuming** computation.

![waiting on a yield](../website/static/docs/blog/contract-wait-yield.png)
*Contracts can now yield the execution of a function until an external service signals that the result is ready*

### What is exactly being yielded?
It is important to notice that the contract is not **halting itself**, or **halting in the middle of a computation**. Instead, the contract is simply **delaying the execution of a callback** until an external agent signals that it is ok to resume.

:::danger
Just as with callbacks in cross-contract calls, people can keep calling functions con the contract between the `yield` and the `resume`, meaning that the state **can change**.

Moreover, since the function used to signal is public, developers must make sure to guard it properly to avoid unwanted calls. This can be done by simply checking the caller of the function.
:::

### How does it change for the user?
Between the `yield` and `resume` the user will simply be waiting to get the result. The maximum time to wait is 500 blocks - around 10 minutes - before the protocol kills the `yield`. This however is much larger than what `300Tgas` can get you while looping.

Even better, the user does not need to expend any gas while waiting, since the contract will simply be waiting for the external service to signal the result.

## How I can use yield/resume in my contract?
While we have not created any official `yield/resume` example, you can take a look to [Saketh Are's example](https://github.com/near/near-sdk-rs/pull/1133/files), whom has been working on the implementation.

The basic idea is that the SDK now exposes two functions:
- A `yield(function_to_yield)` that returns a `yield_ID` which identifies the yield
- A `resume(yield_ID)` that signals which instance of `function_to_yield` can now execute

#### Simplified Example

```rust
// const DATA_ID_REGISTER: u64 = 0;

pub fn request_weather(&mut self, city: String) {
    let index = self.next_available_request_index;
    self.next_available_request_index += 1;

    let yield_promise = env::promise_yield_create(
        "return_result",
        &serde_json::to_vec(&(index,)).unwrap(),
        SIGN_ON_FINISH_CALL_GAS,
        GasWeight(0),
        DATA_ID_REGISTER,
    );

    // Store the request, that an external service will fetch
    let data_id: CryptoHash =
        env::read_register(DATA_ID_REGISTER).expect("").try_into().expect("");
    self.requests.insert(&index, WeatherRequest{&data_id, &city});

    // The return for this function will be the return of "return_value"
    env::promise_return(yield_promise);
}

/// Called by external participants to submit a signature
pub fn respond(&mut self, data_id: String, signature: String) {
    let mut data_id_buf = [0u8; 32];
    hex::decode_to_slice(data_id, &mut data_id_buf).expect("");
    let data_id = data_id_buf;

    // check that caller is allowed to respond, signature is valid, etc.
    // ...

    log!("submitting response {} for data id {:?}", &signature, &data_id);
    env::promise_yield_resume(&data_id, &serde_json::to_vec(&signature).unwrap());
}

/// Callback receiving the externally submitted data (or a PromiseError)
pub fn return_value(
    &mut self,
    request_index: u64,
    #[callback_result] temperature: Result<i32, PromiseError>,
) -> String {
    // Clean up the local state
    self.requests.remove(&request_index);

    match temperature {
        Ok(temperature) => "temperature received: ".to_owned() + &signature,
        Err(_) => "request timed out".to_string(),
    }
}
```

## Conclusion
The ability to `yield` and `resume` computations is a big step forward for the NEAR protocol, as it allows developers to create more complex contracts that rely on external services.

Currently, the feature is only **available on testnet**, and we are looking for feedback on how to improve it.

We expect to have a more user-friendly way to use `yield` and `resume` in the future, so stay tuned!