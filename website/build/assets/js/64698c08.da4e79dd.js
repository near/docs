"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8638],{58216:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var s=n(85893),r=n(11151),a=n(35148);const i=n.p+"assets/images/enum-a-d-block--eizaconiendo.near--eiza_coniendo-b07ea31befc5e196552b3c84bb924974.png",o={sidebar_position:3,sidebar_label:"Using structs and enums",title:"How to think about structs and enums when writing a Rust smart contract on NEAR"},c="Structs and enums",l={id:"tutorials/crosswords/beginner/structs-enums",title:"How to think about structs and enums when writing a Rust smart contract on NEAR",description:"Overview",source:"@site/../docs/3.tutorials/crosswords/02-beginner/02-structs-enums.md",sourceDirName:"3.tutorials/crosswords/02-beginner",slug:"/tutorials/crosswords/beginner/structs-enums",permalink:"/tutorials/crosswords/beginner/structs-enums",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/3.tutorials/crosswords/02-beginner/02-structs-enums.md",tags:[],version:"current",lastUpdatedBy:"matiasbenary",lastUpdatedAt:1720020198e3,sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Using structs and enums",title:"How to think about structs and enums when writing a Rust smart contract on NEAR"},sidebar:"tutorials",previous:{title:"Store multiple puzzles",permalink:"/tutorials/crosswords/beginner/collections"},next:{title:"Actions and sending NEAR",permalink:"/tutorials/crosswords/beginner/actions"}},d={},u=[{value:"Overview",id:"overview",level:2},{value:"Structs",id:"structs",level:3},{value:"Enums",id:"enums",level:3},{value:"Using structs",id:"using-structs",level:2},{value:"Storing contract state",id:"storing-contract-state",level:3},{value:"Returning data",id:"returning-data",level:3},{value:"Using returned objects in a callback",id:"using-returned-objects-in-a-callback",level:3},{value:"Using enums",id:"using-enums",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"structs-and-enums",children:"Structs and enums"}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.h3,{id:"structs",children:"Structs"}),"\n",(0,s.jsxs)(t.p,{children:["If you're not familiar with Rust, it may be confusing that there are no classes or inheritance like other programming languages. We'll be exploring how to ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/book/ch05-01-defining-structs.html",children:"use structs"}),", which are someone similar to classes, but perhaps simpler."]}),"\n",(0,s.jsxs)(t.p,{children:["Remember that there will be only one struct that gets the ",(0,s.jsxs)(t.a,{href:"/build/smart-contracts/anatomy/",children:[(0,s.jsx)(t.code,{children:"#[near]"})," macro"]})," placed on it; our primary struct or singleton if you wish. Oftentimes the primary struct will contain additional structs that may, in turn, contain more structs in a neat and orderly way. You may also have structs that are used to return data to an end user, like a frontend. We'll be covering both of these cases in this chapter."]}),"\n",(0,s.jsx)(t.h3,{id:"enums",children:"Enums"}),"\n",(0,s.jsxs)(t.p,{children:["Enums are short for enumerations, and can be particularly useful if you have entities in your smart contract that transition to different states. For example, say you have a series of blockchain games where players can join, battle, and win. There might be an enumeration for  ",(0,s.jsx)(t.code,{children:"AcceptingPlayers"}),", ",(0,s.jsx)(t.code,{children:"GameInProgress"}),", and ",(0,s.jsx)(t.code,{children:"GameCompleted"}),". Enums are also used to define discrete types of concept, like months in a year."]}),"\n",(0,s.jsx)(t.p,{children:"For our crossword puzzle, one example of an enum is the direction of the clue: either across (A) or down (D) as illustrated below. These are the only two options."}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:i,alt:"Children's toy of a box that has blocks that only fit certain shapes, resembling the letters A and D. Art created by eizaconiendo.near",width:"600"}),(0,s.jsxs)("figcaption",{children:["Art by ",(0,s.jsx)("a",{href:"https://twitter.com/eiza_coniendo",target:"_blank",rel:"noopener noreferrer",children:"eizaconiendo.near"})]})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(t.p,{children:["Rust has an interesting feature where enums can contain additional data. You can see ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/custom_types/enum.html",children:"examples of that here"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"using-structs",children:"Using structs"}),"\n",(0,s.jsx)(t.h3,{id:"storing-contract-state",children:"Storing contract state"}),"\n",(0,s.jsx)(t.p,{children:"We're going to introduce several structs all at once. These structs are addressing a need from the previous chapter, where the puzzle itself was hardcoded and looked like this:"}),"\n",(0,s.jsx)("img",{src:a.Z,alt:"Basic crossword puzzle from chapter 1",width:"600"}),"\n",(0,s.jsx)(t.p,{children:"In this chapter, we want the ability to add multiple, custom crossword puzzles. This means we'll be storing information about the clues in the contract state. Think of a grid where there are x and y coordinates for where a clue starts. We'll also want to specify:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Clue number"}),"\n",(0,s.jsxs)(t.li,{children:["Whether it's ",(0,s.jsx)(t.strong,{children:"across"})," or ",(0,s.jsx)(t.strong,{children:"down"})]}),"\n",(0,s.jsx)(t.li,{children:"The length, or number of letters in the answer"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Let's dive right in, starting with our primary struct:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct Crossword {\n    puzzles: LookupMap<String, Puzzle>,  // \u27f5 Puzzle is a struct we're defining\n    unsolved_puzzles: UnorderedSet<String>,\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{title:"Let's ignore a couple of things\u2026",type:"note",children:(0,s.jsxs)(t.p,{children:["For now, let's ignore the macros about the structs that begin with ",(0,s.jsx)(t.code,{children:"derive"})," and ",(0,s.jsx)(t.code,{children:"near"}),"."]})}),"\n",(0,s.jsxs)(t.p,{children:["Look at the fields inside the ",(0,s.jsx)(t.code,{children:"Crossword"})," struct above, and you'll see a couple types. ",(0,s.jsx)(t.code,{children:"String"})," is a part of Rust's standard library, but ",(0,s.jsx)(t.code,{children:"Puzzle"})," is something we've created:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [borsh])]\n#[derive(Debug)]\npub struct Puzzle {\n    status: PuzzleStatus,  // \u27f5 An enum we'll get to soon\n    /// Use the CoordinatePair assuming the origin is (0, 0) in the top left side of the puzzle.\n    answer: Vec<Answer>,  // \u27f5 Another struct we've defined\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Let's focus on the ",(0,s.jsx)(t.code,{children:"answer"})," field here, which is a vector of ",(0,s.jsx)(t.code,{children:"Answer"}),'s. (A vector is nothing fancy, just a bunch of items or a "growable array" as described in the ',(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/std/vec/struct.Vec.html",children:"standard Rust documentation"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json, borsh])]\n#[derive(Debug)]\npub struct Answer {\n    num: u8,\n    start: CoordinatePair,  // \u27f5 Another struct we've defined\n    direction: AnswerDirection,  // \u27f5 An enum we'll get to soon\n    length: u8,\n    clue: String,\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now let's take a look at the last struct we'e defined, that has cascaded down from fields on our primary struct: the ",(0,s.jsx)(t.code,{children:"CoordinatePair"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json, borsh])]\n#[derive(Debug)]\npub struct CoordinatePair {\n    x: u8,\n    y: u8,\n}\n"})}),"\n",(0,s.jsxs)(t.admonition,{title:"Summary of the structs shown",type:"info",children:[(0,s.jsx)(t.p,{children:"There are a handful of structs here, and this will be a typical pattern when we use structs to store contract state."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Crossword \u27f5 primary struct with #[near(contract_state)]\n\u2514\u2500\u2500 Puzzle\n   \u2514\u2500\u2500 Answer\n      \u2514\u2500\u2500 CoordinatePair\n"})})]}),"\n",(0,s.jsx)(t.h3,{id:"returning-data",children:"Returning data"}),"\n",(0,s.jsx)(t.p,{children:"Since we're going to have multiple crossword puzzles that have their own, unique clues and positions in a grid, we'll want to return puzzle objects to a frontend."}),"\n",(0,s.jsxs)(t.admonition,{title:"Quick note on return values",type:"tip",children:[(0,s.jsx)(t.p,{children:"By default, return values are serialized in JSON unless explicitly directed to use Borsh for binary serialization."}),(0,s.jsx)(t.p,{children:"For example, if we call this function:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'pub fn return_some_words() -> Vec<String> {\n    vec!["crossword".to_string(), "puzzle".to_string()]\n}\n'})}),(0,s.jsx)(t.p,{children:"The return value would be a JSON array:"}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:'["crossword", "puzzle"]'})}),(0,s.jsxs)(t.p,{children:["While somewhat advanced, you can learn more about ",(0,s.jsx)(t.a,{href:"/build/smart-contracts/anatomy/serialization-protocols",children:"changing the serialization here"}),"."]})]}),"\n",(0,s.jsxs)(t.p,{children:["We have a struct called ",(0,s.jsx)(t.code,{children:"JsonPuzzle"})," that differs from the ",(0,s.jsx)(t.code,{children:"Puzzle"})," struct we've shown. It has one difference: the addition of the ",(0,s.jsx)(t.code,{children:"solution_hash"})," field."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json])]\npub struct JsonPuzzle {\n    /// The human-readable (not in bytes) hash of the solution\n    solution_hash: String,  // \u27f5 this field is not contained in the Puzzle struct\n    status: PuzzleStatus,\n    answer: Vec<Answer>,\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This is handy because our primary struct has a key-value pair where the key is the solution hash (as a ",(0,s.jsx)(t.code,{children:"String"}),") and the value is the ",(0,s.jsx)(t.code,{children:"Puzzle"})," struct."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub struct Crossword {\n    puzzles: LookupMap<String, Puzzle>,\n    //               key \u2197        \u2196 value\n    \u2026\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Our ",(0,s.jsx)(t.code,{children:"JsonPuzzle"})," struct returns the information from both the key and the value."]}),"\n",(0,s.jsx)(t.p,{children:"We can move on from this topic, but suffice it to say, sometimes it's helpful to have structs where the intended use is to return data in a more meaningful way than might exist from the structs used to store contract data."}),"\n",(0,s.jsx)(t.h3,{id:"using-returned-objects-in-a-callback",children:"Using returned objects in a callback"}),"\n",(0,s.jsx)(t.p,{children:"Don't be alarmed if this section feels confusing at this point, but know we'll cover Promises and callbacks later."}),"\n",(0,s.jsx)(t.p,{children:'Without getting into detail, a contract may want to make a cross-contract call and "do something" with the return value. Sometimes this return value is an object we\'re expecting, so we can define a struct with the expected fields to capture the value. In other programming languages this may be referred to as "casting" or "marshaling" the value.'}),"\n",(0,s.jsxs)(t.p,{children:["A real-world example of this might be the ",(0,s.jsx)(t.a,{href:"https://nomicon.io/Standards/StorageManagement.html",children:"Storage Management standard"}),", as used in a ",(0,s.jsx)(t.a,{href:"https://github.com/near-examples/FT",children:"fungible token"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's say a smart contract wants to determine if ",(0,s.jsx)(t.code,{children:"alice.near"}),' is "registered" on the ',(0,s.jsx)(t.code,{children:"nDAI"})," token. More technically, does ",(0,s.jsx)(t.code,{children:"alice.near"})," have a key-value pair for herself in the fungible token contract."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json])]\npub struct StorageBalance {\n    pub total: U128,\n    pub available: U128,\n}\n\n// \u2026\n// Logic that calls the nDAI token contract, asking for alice.near's storage balance.\n// \u2026\n\n#[private]\npub fn my_callback(&mut self, #[callback] storage_balance: StorageBalance) {\n    // \u2026\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"The crossword puzzle will eventually use a cross-contract call and callback, so we can look forward to that. For now just know that if your contract expects to receive a return value that's not a primitive (unsigned integer, string, etc.) and is more complex, you may use a struct to give it the proper type."}),"\n",(0,s.jsx)(t.h2,{id:"using-enums",children:"Using enums"}),"\n",(0,s.jsx)(t.p,{children:"In the section above, we saw two fields in the structs that had an enum type:"}),"\n",(0,s.jsxs)(t.p,{children:["1.",(0,s.jsx)(t.code,{children:"AnswerDirection"})," \u2014 this is the simplest type of enum, and will look familiar from other programming languages. It provides the only two options for how a clue in oriented in a crossword puzzle: across and down."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json, borsh])]\n#[derive(Debug)]\npub enum AnswerDirection {\n    Across,\n    Down,\n}\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"PuzzleStatus"})," \u2014 this enum can actually store a string inside the ",(0,s.jsx)(t.code,{children:"Solved"})," structure. (Note that we could have simply stored a string instead of having a structure, but a structure might make this easier to read.)"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'As we improve our crossword puzzle, the idea is to give the winner of the crossword puzzle (the first person to solve it) the ability to write a memo. (For example: "Took me forever to get clue six!", "Alice rules!" or whatever.)'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"#[near(serializers = [json, borsh])]\n#[derive(Debug)]\npub enum PuzzleStatus {\n    Unsolved,\n    Solved { memo: String },\n}\n"})})]})}function m(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},35148:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/basics-crossword-2f471ec61520f252fe4526be2c4ff72c.jpg"},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var s=n(67294);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);