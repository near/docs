---
id: coin-flip
title: Coin Flip
---



Coin Flip is a game where the player tries to guess the outcome of a coin flip. It is one of the simplest contracts implementing random numbers.

![img](/docs/assets/examples/coin-flip.png)

---

## Starting the Game
You have two options to start the example:
1. **Recommended:** use the app through Gitpod (a web-based interactive environment)
2. Clone the project locally.

| Gitpod                                                                                                                                                            | Clone locally                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------------------------------------------------  |
| <a href="https://gitpod.io/#https://github.com/near-examples/coin-flip-examples.git" target="_blank" rel="noopener noreferrer"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod" /></a> | `https://github.com/near-examples/coin-flip-examples.git` |


If you choose Gitpod, a new browser window will open automatically with the code. Give it a minute, and the front-end will pop up (ensure the pop-up window is not blocked).

If you are running the app locally, you should build and deploy a contract (JavaScript or Rust version) and a client manually.

---

## Interacting With the Counter
Go ahead and log in with your NEAR account. If you don't have one, you can create one on the fly. Once logged in, use the `tails` and `heads` buttons to try to guess the next coin flip outcome.

![img](/docs/assets/examples/coin-flip.png)
*Frontend of the Game*

---

## Structure of a dApp

Now that you understand what the dApp does, let us take a closer look to its structure:

1. The frontend code lives in the `/frontend` folder.
2. The smart contract code in Rust is in the `/contract-rs` folder.
3. The smart contract code in JavaScript is in the `/contract-ts` folder.

:::note
Both Rust and JavaScript versions of the contract implement the same functionality.
:::

### Contract
The contract presents 2 methods: `flip_coin`, and `points_of`.

<CodeTabs>
  <Language value="js" language="ts">
    ```
  @call({})
  flip_coin({ player_guess }: { player_guess: Side }): Side {
    // Check who called the method
    const player: AccountId = near.predecessorAccountId();
    near.log(`${player} chose ${player_guess}`);

    // Simulate a Coin Flip
    const outcome = simulateCoinFlip();

    // Get the current player points
    let player_points: number = this.points.get(player, { defaultValue: 0 })

    // Check if their guess was right and modify the points accordingly
    if (player_guess == outcome) {
      near.log(`The result was ${outcome}, you get a point!`);
      player_points += 1;
    } else {
      near.log(`The result was ${outcome}, you lost a point`);
      player_points = player_points ? player_points - 1 : 0;
    }

    // Store the new points
    this.points.set(player, player_points)

    return outcome
  }

  // View how many points a specific player has
  @view({})
  points_of({ player }: { player: AccountId }): number {
    const points = this.points.get(player, { defaultValue: 0 })
    near.log(`Points for ${player}: ${points}`)
    return points
  }
}
```
  </Language>
  <Language value="rust" language="rust">
    ```
    pub fn flip_coin(&mut self, player_guess: String) -> String {
        // Check who called the method
        let player: AccountId = env::predecessor_account_id();
        log_str(&format!("{player} chose {player_guess}"));

        // Simulate a Coin Flip
        let outcome = simulate_coin_flip();

        // Get the current player points
        let mut player_points = self.points.get(&player).unwrap_or(0);

        // Check if their guess was right and modify the points accordingly
        if outcome.eq(&player_guess) {
            player_points = player_points + 1;
        } else {
            player_points = player_points.saturating_sub(1);
        };

        log_str(&format!("player_points: {player_points}"));

        // Store the new points
        self.points.insert(&player, &player_points);

        return outcome;
    }

```
  </Language>
</CodeTabs>

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `_app.js` and `index.js` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  ```

import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';
import { setupMeteorWallet } from '@near-wallet-selector/meteor-wallet';
import { setupMeteorWalletApp } from '@near-wallet-selector/meteor-wallet-app';
import { setupBitteWallet } from '@near-wallet-selector/bitte-wallet';
import { setupEthereumWallets } from '@near-wallet-selector/ethereum-wallets';
import { setupHotWallet } from '@near-wallet-selector/hot-wallet';
import { setupLedger } from '@near-wallet-selector/ledger';
import { setupSender } from '@near-wallet-selector/sender';
import { setupHereWallet } from '@near-wallet-selector/here-wallet';
import { setupNearMobileWallet } from '@near-wallet-selector/near-mobile-wallet';
import { setupWelldoneWallet } from '@near-wallet-selector/welldone-wallet';
import { WalletSelectorProvider } from '@near-wallet-selector/react-hook';
import { Navigation } from '@/components/Navigation';
import { NetworkId, CoinFlipContract } from '@/config';
import { wagmiConfig, web3Modal } from '@/wallets/web3modal';

import '@/styles/globals.css';
import '@near-wallet-selector/modal-ui/styles.css';

const walletSelectorConfig = {
  network: NetworkId,
  createAccessKeyFor: CoinFlipContract,
  modules: [
    setupEthereumWallets({ wagmiConfig, web3Modal, alwaysOnboardDuringSignIn: true }),
    setupBitteWallet(),
    setupMeteorWallet(),
    setupMeteorWalletApp({contractId: CoinFlipContract}),
    setupHotWallet(),
    setupLedger(),
    setupSender(),
    setupHereWallet(),
    setupNearMobileWallet(),
    setupWelldoneWallet(),
    setupMyNearWallet(),
  ],
}

export default function App({ Component, pageProps }) {

  return (
    <WalletSelectorProvider config={walletSelectorConfig}>
      <Navigation />
      <Component {...pageProps} />
    </WalletSelectorProvider>
  );
}
```
  ```
import { useEffect, useState } from "react";

import Coin from "@/components/Coin";
import { useWalletSelector } from '@near-wallet-selector/react-hook';
import { CoinFlipContract } from "@/config";
import styles from "@/styles/app.module.css";


export default function Home() {
	const { signedAccountId, callFunction, viewFunction } = useWalletSelector();
	const [side, setSide] = useState(null);
	const [status, setStatus] = useState("Waiting for user input");
	const [points, setPoints] = useState(0);
	const [choice, setChoice] = useState();

	useEffect(() => {
		if (!signedAccountId) return;
       viewFunction({
			contractId: CoinFlipContract,
			method: "points_of",
			args: { player: signedAccountId },
		}).then((score) => setPoints(score))

	}, [signedAccountId]);

	const handleChoice = async (guess) => {
		setStatus("Asking the contract to flip a coin");
		setChoice(guess);
		setSide("loading");

		let outcome = await callFunction({
			contractId: CoinFlipContract,
			method: "flip_coin",
			args: { player_guess: guess },
		});

		setSide(outcome);
		setStatus(`The outcome was ${outcome}`);

		if (guess === outcome) {
			setStatus("You were right, you won a point!");
			setPoints(points + 1);
		} else {
			setStatus("You were wrong, you lost a point");
			setPoints(points ? points - 1 : 0);
		}
	};

	let color = choice === side ? "btn-success" : "btn-danger";

	return (
		<main className={styles.main}>
			<div className="container">
				{!signedAccountId && (
					<h2 className="text-center">
						<strong>Welcome! Login to Play</strong>
					</h2>
				)}
				<Coin side={side} />
				{signedAccountId && (
					<div className="container mt-5">
						<h2 className="text-center mb-4">
							What do you think is coming next?
						</h2>
						<div className="d-flex justify-content-center">
							<button
								className={`btn me-2 ${choice === "heads" && side !== 'loading' ? color : "btn-primary"
									}`}
								onClick={() => handleChoice("heads")}
							>
								Heads
							</button>
							<button
								className={`btn ${choice === "tails" && side !== 'loading' ? color : "btn-primary"
									}`}
								onClick={() => handleChoice("tails")}
							>
								Tails
							</button>
						</div>
						<p className="mt-3">
							<strong>Status</strong>: {status}
						</p>
						<h3 className="mt-4">
							Your points so far:
							<span className="ms-2 badge bg-secondary">{points}</span>
						</h3>
					</div>
				)}
			</div>
		</main>
	);
}

```                        
</Language>

---

## Testing

When writing smart contracts, it is very important to test all methods exhaustively. In this
project you have integration tests. Before digging into them, go ahead and perform the tests present in the dApp through the command `yarn test` for the JavaScript version, or `./test.sh` for the Rust version.

### Integration test

Integration tests can be written in both Rust and JavaScript. They automatically deploy a new
contract and execute methods on it. In this way, integration tests simulate interactions
from users in a realistic scenario. You will find the integration tests for the `coin-flip`
in `contract-ts/sandbox-ts` (for the JavaScript contract) and `contract-rs/tests` (for the Rust contract).

<CodeTabs>
  <Language value="js" language="ts">
    ```
test('by default the user has no points', async (t) => {
  const { root, contract } = t.context.accounts;
  const points = await contract.view('points_of', { player: root.accountId });
  t.is(points, 0);
});

test('the points are correctly computed', async (t) => {
  const { root, contract } = t.context.accounts;

  let counter = { 'heads': 0, 'tails': 0 }
  let expected_points = 0;

  for(let i=0; i<10; i++){
    const res = await root.call(contract, 'flip_coin', { 'player_guess': 'heads' })
    counter[res] += 1;
    expected_points += res == 'heads' ? 1 : -1;
    expected_points = Math.max(expected_points, 0);
  }

  // A binomial(10, 1/2) has a P(x>2) ~ 0.98%
  t.true(counter['heads'] >= 2);
  t.true(counter['tails'] >= 2);

  const points = await contract.view('points_of', { 'player': root.accountId });
  t.is(points, expected_points);
});
```
  </Language>
  <Language value="rust" language="rust">
    ```
async fn test_user_has_no_points(
    user: &Account,
    contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
    let points: u8 = user
        .call(contract.id(), "points_of")
        .args_json(json!({ "player": user.id()}))
        .transact()
        .await?
        .json()?;
 
    assert_eq!(points, 0);
    println!("      Passed ✅ test_user_has_no_points");
    Ok(())
}
 
async fn test_points_are_correctly_computed(
    user: &Account,
    contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut tails_counter = 0;
    let mut heads_counter = 0;
    let mut expected_points = 0;

    let mut i = 0;
    while i < 10 {
        let outcome: String = user.call(contract.id(), "flip_coin")
          .args_json(json!({"player_guess": "tails"}))
          .transact()
          .await?
          .json()?;

        if outcome.eq("tails") {
          tails_counter = tails_counter + 1;
          expected_points = expected_points + 1;
        } else {
          heads_counter = heads_counter + 1;
          if expected_points > 0 {
            expected_points = expected_points - 1;
          }
        }
        i = i + 1;
    }

    assert!(heads_counter >= 2);
    assert!(tails_counter >= 2);
    
    let points: u8 = user
        .call(contract.id(), "points_of")
        .args_json(json!({ "player": user.id()}))
        .transact()
        .await?
        .json()?;
 
    assert_eq!(points, expected_points);
    println!("      Passed ✅ test_points_are_correctly_computed");
    Ok(())
}
```
  </Language>
</CodeTabs>

---

## A Note On Randomness

Randomness in the blockchain is a complex subject. We recommend you to read and investigate about it.
You can start with our [security page on it](../../smart-contracts/security/random.md).

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::
