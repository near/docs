---
id: coin-flip
title: How to handle and use randomness on-chain
description: "Learn to build a coin flip game smart contract with randomness, betting mechanics, and reward distribution on NEAR Protocol."
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example demonstrates a simple coin flip game on the NEAR blockchain, where players can guess the outcome of a coin flip and earn points. It includes both the smart contract and the frontend components.

![img](/docs/assets/examples/coin-flip.png)

---

## Starting the Game
Coin Flip is a game where the player tries to guess the outcome of a coin flip. It is one of the simplest contracts implementing random numbers.

You have two options to start the example:
1. **Recommended:** use the app through Gitpod (a web-based interactive environment)
2. Clone the project locally.

| Gitpod                                                                                                                                                            | Clone locally                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------------------------------------------------  |
| <a href="https://gitpod.io/#https://github.com/near-examples/coin-flip-examples.git" target="_blank" rel="noopener noreferrer"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod" /></a> | `https://github.com/near-examples/coin-flip-examples.git` |


If you choose Gitpod, a new browser window will open automatically with the code. Give it a minute, and the front-end will pop up (ensure the pop-up window is not blocked).

If you are running the app locally, you should build and deploy a contract (JavaScript or Rust version) and a client manually.

---

## Interacting With the Counter
Go ahead and log in with your NEAR account. If you don't have one, you can create one on the fly. Once logged in, use the `tails` and `heads` buttons to try to guess the next coin flip outcome.

![img](/docs/assets/examples/coin-flip.png)
*Frontend of the Game*

---

## Structure of a dApp

Now that you understand what the dApp does, let us take a closer look to its structure:

1. The frontend code lives in the `/frontend` folder.
2. The smart contract code in Rust is in the `/contract-rs` folder.
3. The smart contract code in JavaScript is in the `/contract-ts` folder.

:::note
Both Rust and JavaScript versions of the contract implement the same functionality.
:::

### Contract
The contract presents 2 methods: `flip_coin`, and `points_of`.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/src/contract.ts"
            start="23" end="56" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/src/lib.rs"
            start="46" end="70" />
  </Language>
</CodeTabs>

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `_app.js` and `index.js` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  <Github fname="_app.js"
          url="https://github.com/near-examples/coin-flip-workshop-js/blob/main/frontend/src/pages/_app.js"/>
  <Github fname="index.js"
          url="https://github.com/near-examples/coin-flip-workshop-js/blob/main/frontend/src/pages/index.js"/>                        
</Language>

---

## Testing

When writing smart contracts, it is very important to test all methods exhaustively. In this
project you have integration tests. Before digging into them, go ahead and perform the tests present in the dApp through the command `yarn test` for the JavaScript version, or `./test.sh` for the Rust version.

### Integration test

Integration tests can be written in both Rust and JavaScript. They automatically deploy a new
contract and execute methods on it. In this way, integration tests simulate interactions
from users in a realistic scenario. You will find the integration tests for the `coin-flip`
in `contract-ts/sandbox-ts` (for the JavaScript contract) and `contract-rs/tests` (for the Rust contract).

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="main.test.js"
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
            start="32" end="57" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/tests/tests.rs"
            start="25" end="82" />
  </Language>
</CodeTabs>

---

## Understanding NEAR's Random Seed

Understanding how NEAR's random seed mechanism works is crucial for building secure applications that rely on randomness. Unlike other blockchains that struggle with randomness, NEAR provides a built-in solution that's both elegant and practical.

### How NEAR's Randomness Works

NEAR's random seed is **deterministic and verifiable**, created through a clever cryptographic process:

The random seed comes from the validator who produces each block. It's generated by the validator signing the previous block hash with their private key. This creates a randomness source that's both unpredictable (you can't know the validator's private key) and tamper-proof (the validator has to sign a specific previous block hash).

### Randomness in the Coin Flip Game

In our coin flip example, the randomness is implemented in the `flip_coin` method:

```typescript
const outcome = random_seed_array()[0] % 2 == 0 ? Side.Heads : Side.Tails;
```

This line takes the first byte of NEAR's cryptographic random seed and uses it to determine heads or tails. The `random_seed_array()` function returns the validator's signature of the previous block hash, providing cryptographically secure randomness.

### Properties of NEAR's Random Seed

NEAR's random seed has specific characteristics that affect how you design applications:

**Immediate availability**: The random seed is available instantly in the same transaction, unlike solutions requiring multiple blocks or external oracles.

**Verifiable**: Anyone can cryptographically verify that the random seed was generated correctly by checking the validator's signature.

**Validator predictability**: Only the current validator can predict the outcome before the block is mined, since they know their own private key.

### Design Patterns for Enhanced Security

While the simple approach in our coin flip example works well for demonstrations, you can enhance security by separating user input from randomness resolution:

```typescript
// Step 1: User places bet
@call({})
place_bet({ guess }: { guess: Side }): void {
  const player = near.predecessorAccountId();
  this.pending_bets.set(player, {
    guess,
    block_height: near.blockIndex()
  });
}

// Step 2: Resolve bet in a later block
@call({})
resolve_bet(): string {
  const player = near.predecessorAccountId();
  const bet = this.pending_bets.get(player);
  
  // Ensure bet was placed in a previous block
  assert(near.blockIndex() > bet.block_height, "Must wait for next block");
  
  const outcome = random_seed_array()[0] % 2 == 0 ? Side.Heads : Side.Tails;
  // ... resolve the bet with the random outcome
}
```

This two-step approach ensures that the validator cannot know the random outcome when the user places their bet.

### When to Use Each Approach

**Single-block randomness** (like our coin flip example) is perfect for:
- Educational examples and demonstrations
- Low-stakes games where simplicity matters more than perfect unpredictability
- Applications where validator advantage is acceptable

**Multi-block randomness** is better for:
- High-stakes applications with significant rewards
- Situations where fairness is paramount
- Games where validator predictability could be problematic

---

## A Note On Randomness

Randomness in the blockchain is a complex subject. NEAR's random seed provides a practical solution that balances security, usability, and verifiability. For most applications needing randomness, NEAR's built-in random seed offers a clean, accessible solution without requiring external oracles or complex commit-reveal schemes.

We recommend you to read and investigate more about blockchain randomness. You can start with our [security page on it](../../smart-contracts/security/random.md).

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::
