---
id: deploy
title: Deploying to Testnet
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

In the previous section we went through the contract's code, analyzing how it worked. Now, we need to test it and make sure it works as expected! For contracts there are two types of testing you can do: unit testing and sandbox testing.

Here, we will focus on the sandbox testing, as it enables to deploy the contract in a realistic environment, allowing us to create multiple accounts and interact with the contract as if it was deployed on the blockchain.

:::info unit testing

Unit tests are built-in in the language, and used to test the contract functions individually. These tests work well when little context is required. However, they cannot test chain interactions - like sending accounts $NEAR tokens - since they need to be processed by the network.

:::

---

## Account Creation

The first thing our test does is to create multiple accounts with 10 $NEAR tokens each, and deploy the contract into one of them.

<Tabs groupId="code-tabs">
    <TabItem value="js" label="ðŸŒ JavaScript">
        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L12"
                start="12" end="22" />
        
        To deploy the contract, we pass the path to the compiled WASM contract as an argument to the test in `package.json`. Indeed, when executing `npm run test`, the command will first compile the contract and then run the tests.

    </TabItem>
    <TabItem value="rust" label="ðŸ¦€ Rust">
        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs#L10"
                start="17" end="28" />

        Notice that the sandbox compiles the code itself, so we do not need to pre-compile the contract before running the tests.
    </TabItem>
</Tabs>

---

## Contract Initialization

To initialize the contract the contract's account calls itself, invoking the `init` function with an `end_time` set to 60 seconds in the future.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="ðŸŒ JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js"
                start="25" end="27" />

:::warning Time Units

The contract measures time in **nanoseconds**, for which we need to multiply the result of `Date.now()` (expressed in milliseconds) by `10^6`

:::

    </TabItem>

    <TabItem value="rust" label="ðŸ¦€ Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs"
                start="30" end="37" />

:::warning Time Units

The contract measures time in **nanoseconds**, for which we need to multiply the result of `Utc::now().timestamp()` (expressed in seconds) by `10^9`

:::

    </TabItem>
</Tabs>

:::info Time is a String

Notice that the time is passed as a `String` to the contract, this is because smart contracts cannot receive numbers larger than `52 bits` and we want to pass a `unix timestamp` in **nanoseconds**

:::

---

## Bidding

Now that the contract is deployed and initialized, we can start biding and checking if the contract behaves as expected.

We first make `alice` place a bid of 1 NEAR, and check that the contract correctly registers the bid. Then, we make `bob` place a bid of 2 NEAR, and check that the highest bid is updated, and that `alice` gets its NEAR refunded.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="ðŸŒ JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js"
                start="45" end="60" />

    </TabItem>

    <TabItem value="rust" label="ðŸ¦€ Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs"
                start="41" end="73" />

    </TabItem>

</Tabs>

#### Checking the balance
It is important to notice how we check if `alice` was refunded. We query her balance after her first bid, and then check if it has increased by 1 NEAR after `bob` makes his bid. 

You might be tempted to check if `alice`'s balance is exactly 10 NEAR after she gets refunded, but `alice` balance cannot be 10 NEAR anymore, because some $NEAR was **consumed as `gas` fees** when `alice` called `bid`.

#### Testing invalid calls

When testing we should also check that the contract does not allow invalid calls. The next part checks that the contract doesn't allow for bids with fewer $NEAR tokens than the previous to be made.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="ðŸŒ JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L63"
                start="63" end="63" />

    </TabItem>

    <TabItem value="rust" label="ðŸ¦€ Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs"
                start="76" end="82" />

    </TabItem>

</Tabs>

---

## Fast Forwarding Time
The sandbox allows us to fast forward time, which is useful to test the contract when the auction is over. The test advances 200 blocks in order to pass a minute, and thus finishing the auction.

Any bid made after the auction ends should be rejected.

<Tabs groupId="code-tabs">
    <TabItem value="js" label="ðŸŒ JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js"
                start="65" end="69" />

    </TabItem>
    <TabItem value="rust" label="ðŸ¦€ Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs"
                start="85" end="95" />

    </TabItem>
</Tabs>

---

## Executing the tests 

Now that we understand what we are testing, let's go ahead and run the tests!


<Tabs groupId="code-tabs">

    <TabItem value="js" label="ðŸŒ JavaScript">

        ```
        # if you haven't already, install the dependencies
        npm install

        # run the tests
        npm run test 
        ```

    </TabItem>

    <TabItem value="rust" label="ðŸ¦€ Rust">

        ```
        cargo test
        ```

    </TabItem>

</Tabs>

All tests should pass, and you should see the output of the tests in the console. If you see any errors, please contact us in the [NEAR Discord](https://near.chat) or through [Telegram](https://t.me/neardev) and we'll help you out!

---

## Conclusion 

In this part of the tutorial, we've seen how to use our sandbox testing environment to test the contract. We've tested the contract's initialization, biding, and time advancement.

You are now ready to move to the next section, in which we will deploy the contract to the testnet and interact with it through the CLI.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="ðŸŒ JavaScript">

        ```
        # if you haven't already, install the dependencies
        npm install

        # run the tests
        npm run test 
        ```

        You'll need a testnet account to deploy the contract to, so if you don't have one you can use

        ```
        near account create-account sponsor-by-faucet-service <accountId> autogenerate-new-keypair 
        ```

        Then deploy and initialize the contract with

        ```
        near contract deploy <accountId> use-file <path to WASM> with-init-call init json-args '{"end_time": "300000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet
        ```


    </TabItem>

    <TabItem value="rust" label="ðŸ¦€ Rust">

        Run tests

        ```
        cargo test
        ```

        If all the tests are successful we can build the contract WASM

        ```
        cargo near build
        ```

        You'll need a testnet account to deploy the contract to, so if you don't have one you can use

        ```
        cargo near create-dev-account use-random-account-id
        ```

        Then deploy and initialize the contract with

        ```
        cargo near deploy <accountId> with-init-call init json-args '{"end_time": "300000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet
        ```

    </TabItem>

</Tabs>


Now the contract is deployed and initialized we can send transactions to it using the CLI. NEAR's CLI is interactive meaning you can type `near` and click through all the possible options without having to remember certain commands. But here you can use the following full commands to call the contract's methods:

Call `bid`, you may want to create another testnet account for the signer

```
near contract call-method as-transaction <contractId> bid json-args {} prepaid-gas '100.0 Tgas' attached-deposit '1 NEAR' sign-as <accountId> network-config testnet
```

Call `get_highest_bid`

```
near contract call-method as-read-only <contractId> get_highest_bid json-args {} network-config testnet now
```

---

## Conclusion 

In this part of the tutorial, we've seen how a smart contract stores data, mutates the stored data and views the data. We also looked at how tests are written and how to execute them. Finally, we learned to compile, deploy and interact with the contract through the CLI on testnet. 

There is a core problem to this contract; there needs to exist a key to the contract for the auctioneer to claim the funds. This allows for the key holder to do with the contract as they please, for example withdrawing funds from the contract at any point. In the [next part](./2-locking.md), we'll learn how to lock a contract by specifying an auctioneer on initialization who can claim the funds through a new method we'll introduce.