---
id: agent-contract
title: Agent Contract
sidebar_label: Agent Contract
description: "TODO"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github} from "@site/src/components/codetabs"

When developing this example we started by forking the [default agent contract](https://github.com/NearDeFi/shade-agent-js/tree/main/contracts/sandbox). The structure of the contract is mostly the same but removes the request_signature function and implements DAO specific code.

---

## Contract Structure

The agent contract includes additional state over the default contract. It stores:
- The DAO's manifesto
- A list of pending proposals
- A list of finalized proposals 
- The current proposal ID

<Github fname="lib.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/lib.rs#L33-L41"
    start="33" end="41" />

### Manifesto 

The manifesto contains two parts, the `manifesto text` itself, that states how the DAO should make decisions and the `hash` of the manifesto. The hash will be used to verify that the agent is using the correct manifesto to make its decision.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L7-L10"
    start="7" end="10" />

The manifesto and its hash is set to an empty string when the contract is initialized.

### Pending Proposals

This stores a list of all the proposals that are ready to be responded to by the agent. Each proposal request includes the `proposal text` and `yield ID`. The yield ID is a unique identifier for each active request as part of the yield and resume flow.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L14-L17"
    start="14" end="17" />

The map is set to empty when the contract is initialized.

### Finalized Proposals 

This stores a list of all proposals that have been voted on by the agent. Each finalized proposal contains the `proposal text`, the `proposal result` which is a an enum of `Approved` or `Rejected`, and the `reasoning` for the decision. The result and the reasoning are provided by the agent.

<Tabs groupId="code-tabs">
  <TabItem value="finalized-proposal" label="FinalizedProposal">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L21-L25"
        start="21" end="25" />

  </TabItem>
  <TabItem value="proposal-result" label="ProposalResult">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L29-L32"
        start="29" end="32" />
  
  </TabItem>
</Tabs>

The map is set to empty when the contract is initialized.

### Current Proposal ID

The current proposal ID is an integer identifier of the last proposal request, its used to identify different pending proposals. It increments each proposal request. If a proposal is not voted on by the agent then the proposal ID will still increment leading to non-consecutive proposal IDs within the finalized proposals map. Note that this the proposal ID is different to the yield ID.

The proposal ID is set to zero when the contract is initialized so the first proposal will be one.

---

## Setting the Manifesto

The contract has a function to set the manifesto. This method is restricted so that only the `owner` can set the manifesto. In production the owner would likely be a multisig contract. The contract owner simply provides the text of the manifesto, its hash is computed and both are stored in the contract's state.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L55-L64"
    start="55" end="64" />

---

## Creating a Proposal

When a user calls the `create_proposal` method on the contract, providing the proposal text as args, the method first generates a `yield_id`. This is a unique hash identifier for a yielded promise used to make sure the correct response goes to the correct pending proposal. The yield ID is generated by the register, the register takes an integer identifier since you can have multiple different registers in a contract, in our case we just use zero for our register.

<Tabs groupId="code-tabs">
  <TabItem value="finalized-proposal" label="FinalizedProposal">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L21-L25"
        start="21" end="25" />

  </TabItem>
  <TabItem value="proposal-result" label="ProposalResult">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L71-L74"
        start="71" end="74" />
  
  </TabItem>
</Tabs>


The method then creates a new proposal request and inserts it into the map of pending proposals. This map is used so the agent can fetch the text for the proposals it needs to respond to.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L77-L85"
    start="77" end="85" />

Lastly the method creates a yielded promise. 

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L88-L97"
    start="88" end="96" />

As you can see, the promise will call the `return_external_response` function with arguments of `proposal_id` and `proposal_text` when the promise resolves, i.e. the agent responds or the yield times out.

---

## Agent Response and Validation

Once the agent has made it's decision it will call the `agent_vote` function. This function essentially does some checks that the response is valid and, if so, executes the yielded promise.

The agent responds with the `yield_id` for the promise it intends resume, the `proposal ID` it is voting on, the `hash of the propsal`, the `hash of the manifesto`, the `vote` and the `reasoning` behind the vote.

<Tabs groupId="code-tabs">
  <TabItem value="args" label="Args">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L100"
        start="100" end="100" />

  </TabItem>
  <TabItem value="ai-response" label="AiResponse">

    <Github fname="dao.rs" language="rust"
        url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L35-L41"
        start="35" end="41" />
  
  </TabItem>
</Tabs>

Most importantly, the method first checks if the caller is a valid registered agent, so we can verify that the DAO is making its decision with the process expected.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L102"
    start="102" end="102" />

The method also checks that the hash of the manifesto and the hash of the proposal the agent submits match those stored and expected by the contract. This is done to verify that the agent is using the correct manifesto and proposal when voting on a given proposal. This is required to remove the trust on the RPC that is fetching the proposals and manifesto as there could be a problem in the RPC causing it to fetch the wrong details or the RPC could intentionally provide the wrong details to try to corrupt the vote.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L106-L120"
    start="106" end="120" />

If any of these checks fail then the call will fail and the promise will not be resumed (in this method call, it could be resumed later if called with valid args before the promise times out).

Lastly, if all checks pass, the method will resume the promise, specifying the yield_id it intends to resume and the response from the agent.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L123"
    start="123" end="123" />

---

### Proposal Finalization

When the promise is resumed the `return_external_response` method is called. It's labelled private so that accounts cannot it, only the yielded promise. 

The method takes the arguments passed both from when the promise was created and when it was resumed.

<Github fname="dao.rs" language="rust"
    url="https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L123"
    start="127" end="133" />


---

## Managing State

When using Yield and Resume you need to carefully manage the state of the contract. Because of it's asynchronous execution the yield and the response happen and are finalized in different blocks. 

If you change the state in the function where the yield is made (create_proposal), you need to make sure that you revert the state if the promise times out or the response is invalid. It is fine to panic the function that the agent uses to reply, if the response is invalid (agent_vote), but you must not panic the function in which the promise is resumed (return_external_response), as the yield function will not fail and revert automatically. You should gracefully complete the function and revert the state. 

:::tip
You can learn more about yield and resume in the [yield and resume section](../../../../smart-contracts/anatomy/yield-resume.md) in the docs.
:::


---

## View Methods

The contract exposes [functions](https://github.com/NearDeFi/verifiable-ai-dao/blob/main/contract/src/dao.rs#L189-L224) to get the manifesto text, get the pending proposals and get finalized proposals.